// Generated by tsbindgen - Architecture
// Namespace: Tsonic.Runtime
// Assembly: Tsonic.Runtime

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { Dictionary, IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Func, IEquatable, Int32, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";

export interface IteratorResult_1$instance<T> {
    readonly done: boolean;
    Done: boolean;
    readonly value: T;
    Value: T;
    Deconstruct(Value: T, Done: boolean): void;
    Equals(obj: unknown): boolean;
    Equals(other: IteratorResult_1<T>): boolean;
    GetHashCode(): int;
    ToString(): string;
}


export const IteratorResult_1: {
    new<T>(Value: T, Done: boolean): IteratorResult_1<T>;
};


export type IteratorResult_1<T> = IteratorResult_1$instance<T>;

export interface DictionaryAdapter_1$instance<T> {
    Item: T | undefined;
    readonly Keys: IEnumerable<System_Internal.String>;
    readonly Values: IEnumerable<T | undefined>;
    ContainsKey(key: string): boolean;
    GetDictionary(): Dictionary<System_Internal.String, unknown | undefined>;
}


export const DictionaryAdapter_1: {
    new<T>(dictionary: Dictionary<System_Internal.String, unknown>): DictionaryAdapter_1<T>;
};


export type DictionaryAdapter_1<T> = DictionaryAdapter_1$instance<T>;

export interface DynamicObject$instance {
    get Item(): unknown | undefined;
    set Item(value: unknown);
    GetKeys(): string[];
    GetProperty<T>(key: string): T | undefined;
    GetValues(): (unknown | undefined)[];
    HasProperty(key: string): boolean;
    SetProperty(key: string, value: unknown): void;
    ToDictionary(): Dictionary<System_Internal.String, unknown | undefined>;
}


export const DynamicObject: {
    new(): DynamicObject;
    FromDictionary(properties: Dictionary<System_Internal.String, unknown>): DynamicObject;
};


export type DynamicObject = DynamicObject$instance;

export interface Union_2$instance<T1, T2> {
    As1(): T1;
    As2(): T2;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Is1(): boolean;
    Is2(): boolean;
    Match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>): TResult;
    Match(onT1: Action<T1>, onT2: Action<T2>): void;
    ToString(): string | undefined;
    TryAs1(value: T1): boolean;
    TryAs2(value: T2): boolean;
}


export const Union_2: {
    new<T1, T2>(): Union_2<T1, T2>;
    From1<T1, T2>(value: T1): Union_2<T1, T2>;
    From2<T1, T2>(value: T2): Union_2<T1, T2>;
};


export type Union_2<T1, T2> = Union_2$instance<T1, T2>;

export interface Union_3$instance<T1, T2, T3> {
    As1(): T1;
    As2(): T2;
    As3(): T3;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Is1(): boolean;
    Is2(): boolean;
    Is3(): boolean;
    Match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>): TResult;
    Match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>): void;
    ToString(): string | undefined;
    TryAs1(value: T1): boolean;
    TryAs2(value: T2): boolean;
    TryAs3(value: T3): boolean;
}


export const Union_3: {
    new<T1, T2, T3>(): Union_3<T1, T2, T3>;
    From1<T1, T2, T3>(value: T1): Union_3<T1, T2, T3>;
    From2<T1, T2, T3>(value: T2): Union_3<T1, T2, T3>;
    From3<T1, T2, T3>(value: T3): Union_3<T1, T2, T3>;
};


export type Union_3<T1, T2, T3> = Union_3$instance<T1, T2, T3>;

export interface Union_4$instance<T1, T2, T3, T4> {
    As1(): T1;
    As2(): T2;
    As3(): T3;
    As4(): T4;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Is1(): boolean;
    Is2(): boolean;
    Is3(): boolean;
    Is4(): boolean;
    Match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>): TResult;
    Match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>): void;
    ToString(): string | undefined;
    TryAs1(value: T1): boolean;
    TryAs2(value: T2): boolean;
    TryAs3(value: T3): boolean;
    TryAs4(value: T4): boolean;
}


export const Union_4: {
    new<T1, T2, T3, T4>(): Union_4<T1, T2, T3, T4>;
    From1<T1, T2, T3, T4>(value: T1): Union_4<T1, T2, T3, T4>;
    From2<T1, T2, T3, T4>(value: T2): Union_4<T1, T2, T3, T4>;
    From3<T1, T2, T3, T4>(value: T3): Union_4<T1, T2, T3, T4>;
    From4<T1, T2, T3, T4>(value: T4): Union_4<T1, T2, T3, T4>;
};


export type Union_4<T1, T2, T3, T4> = Union_4$instance<T1, T2, T3, T4>;

export interface Union_5$instance<T1, T2, T3, T4, T5> {
    As1(): T1;
    As2(): T2;
    As3(): T3;
    As4(): T4;
    As5(): T5;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Is1(): boolean;
    Is2(): boolean;
    Is3(): boolean;
    Is4(): boolean;
    Is5(): boolean;
    Match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>): TResult;
    Match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>): void;
    ToString(): string | undefined;
    TryAs1(value: T1): boolean;
    TryAs2(value: T2): boolean;
    TryAs3(value: T3): boolean;
    TryAs4(value: T4): boolean;
    TryAs5(value: T5): boolean;
}


export const Union_5: {
    new<T1, T2, T3, T4, T5>(): Union_5<T1, T2, T3, T4, T5>;
    From1<T1, T2, T3, T4, T5>(value: T1): Union_5<T1, T2, T3, T4, T5>;
    From2<T1, T2, T3, T4, T5>(value: T2): Union_5<T1, T2, T3, T4, T5>;
    From3<T1, T2, T3, T4, T5>(value: T3): Union_5<T1, T2, T3, T4, T5>;
    From4<T1, T2, T3, T4, T5>(value: T4): Union_5<T1, T2, T3, T4, T5>;
    From5<T1, T2, T3, T4, T5>(value: T5): Union_5<T1, T2, T3, T4, T5>;
};


export type Union_5<T1, T2, T3, T4, T5> = Union_5$instance<T1, T2, T3, T4, T5>;

export interface Union_6$instance<T1, T2, T3, T4, T5, T6> {
    As1(): T1;
    As2(): T2;
    As3(): T3;
    As4(): T4;
    As5(): T5;
    As6(): T6;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Is1(): boolean;
    Is2(): boolean;
    Is3(): boolean;
    Is4(): boolean;
    Is5(): boolean;
    Is6(): boolean;
    Match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>, onT6: Func<T6, TResult>): TResult;
    Match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>, onT6: Action<T6>): void;
    ToString(): string | undefined;
    TryAs1(value: T1): boolean;
    TryAs2(value: T2): boolean;
    TryAs3(value: T3): boolean;
    TryAs4(value: T4): boolean;
    TryAs5(value: T5): boolean;
    TryAs6(value: T6): boolean;
}


export const Union_6: {
    new<T1, T2, T3, T4, T5, T6>(): Union_6<T1, T2, T3, T4, T5, T6>;
    From1<T1, T2, T3, T4, T5, T6>(value: T1): Union_6<T1, T2, T3, T4, T5, T6>;
    From2<T1, T2, T3, T4, T5, T6>(value: T2): Union_6<T1, T2, T3, T4, T5, T6>;
    From3<T1, T2, T3, T4, T5, T6>(value: T3): Union_6<T1, T2, T3, T4, T5, T6>;
    From4<T1, T2, T3, T4, T5, T6>(value: T4): Union_6<T1, T2, T3, T4, T5, T6>;
    From5<T1, T2, T3, T4, T5, T6>(value: T5): Union_6<T1, T2, T3, T4, T5, T6>;
    From6<T1, T2, T3, T4, T5, T6>(value: T6): Union_6<T1, T2, T3, T4, T5, T6>;
};


export type Union_6<T1, T2, T3, T4, T5, T6> = Union_6$instance<T1, T2, T3, T4, T5, T6>;

export interface Union_7$instance<T1, T2, T3, T4, T5, T6, T7> {
    As1(): T1;
    As2(): T2;
    As3(): T3;
    As4(): T4;
    As5(): T5;
    As6(): T6;
    As7(): T7;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Is1(): boolean;
    Is2(): boolean;
    Is3(): boolean;
    Is4(): boolean;
    Is5(): boolean;
    Is6(): boolean;
    Is7(): boolean;
    Match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>, onT6: Func<T6, TResult>, onT7: Func<T7, TResult>): TResult;
    Match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>, onT6: Action<T6>, onT7: Action<T7>): void;
    ToString(): string | undefined;
    TryAs1(value: T1): boolean;
    TryAs2(value: T2): boolean;
    TryAs3(value: T3): boolean;
    TryAs4(value: T4): boolean;
    TryAs5(value: T5): boolean;
    TryAs6(value: T6): boolean;
    TryAs7(value: T7): boolean;
}


export const Union_7: {
    new<T1, T2, T3, T4, T5, T6, T7>(): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    From1<T1, T2, T3, T4, T5, T6, T7>(value: T1): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    From2<T1, T2, T3, T4, T5, T6, T7>(value: T2): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    From3<T1, T2, T3, T4, T5, T6, T7>(value: T3): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    From4<T1, T2, T3, T4, T5, T6, T7>(value: T4): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    From5<T1, T2, T3, T4, T5, T6, T7>(value: T5): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    From6<T1, T2, T3, T4, T5, T6, T7>(value: T6): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    From7<T1, T2, T3, T4, T5, T6, T7>(value: T7): Union_7<T1, T2, T3, T4, T5, T6, T7>;
};


export type Union_7<T1, T2, T3, T4, T5, T6, T7> = Union_7$instance<T1, T2, T3, T4, T5, T6, T7>;

export interface Union_8$instance<T1, T2, T3, T4, T5, T6, T7, T8> {
    As1(): T1;
    As2(): T2;
    As3(): T3;
    As4(): T4;
    As5(): T5;
    As6(): T6;
    As7(): T7;
    As8(): T8;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
    Is1(): boolean;
    Is2(): boolean;
    Is3(): boolean;
    Is4(): boolean;
    Is5(): boolean;
    Is6(): boolean;
    Is7(): boolean;
    Is8(): boolean;
    Match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>, onT6: Func<T6, TResult>, onT7: Func<T7, TResult>, onT8: Func<T8, TResult>): TResult;
    Match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>, onT6: Action<T6>, onT7: Action<T7>, onT8: Action<T8>): void;
    ToString(): string | undefined;
    TryAs1(value: T1): boolean;
    TryAs2(value: T2): boolean;
    TryAs3(value: T3): boolean;
    TryAs4(value: T4): boolean;
    TryAs5(value: T5): boolean;
    TryAs6(value: T6): boolean;
    TryAs7(value: T7): boolean;
    TryAs8(value: T8): boolean;
}


export const Union_8: {
    new<T1, T2, T3, T4, T5, T6, T7, T8>(): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From1<T1, T2, T3, T4, T5, T6, T7, T8>(value: T1): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From2<T1, T2, T3, T4, T5, T6, T7, T8>(value: T2): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From3<T1, T2, T3, T4, T5, T6, T7, T8>(value: T3): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From4<T1, T2, T3, T4, T5, T6, T7, T8>(value: T4): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From5<T1, T2, T3, T4, T5, T6, T7, T8>(value: T5): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From6<T1, T2, T3, T4, T5, T6, T7, T8>(value: T6): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From7<T1, T2, T3, T4, T5, T6, T7, T8>(value: T7): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    From8<T1, T2, T3, T4, T5, T6, T7, T8>(value: T8): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
};


export type Union_8<T1, T2, T3, T4, T5, T6, T7, T8> = Union_8$instance<T1, T2, T3, T4, T5, T6, T7, T8>;

export abstract class ArrayHelpers$instance {
    static Slice<T>(source: IEnumerable<T>, startIndex: int): T[];
    static Slice<T>(source: IList<T>, startIndex: int): T[];
    static Slice<T>(source: T[], startIndex: int): T[];
}


export type ArrayHelpers = ArrayHelpers$instance;

export abstract class Operators$instance {
    static instanceof(obj: unknown, type: Type): boolean;
    static typeof(value: unknown): string;
}


export type Operators = Operators$instance;

export abstract class Structural$instance {
    static Clone<T>(source: unknown): T | undefined;
    static CloneFromDictionary<T>(source: Dictionary<System_Internal.String, unknown>): T | undefined;
    static CreateDictionaryAdapter<T>(source: Dictionary<System_Internal.String, unknown>): DictionaryAdapter_1<T>;
    static ToDictionary(source: unknown): Dictionary<System_Internal.String, unknown | undefined>;
}


export type Structural = Structural$instance;

