// Generated by tsbindgen - Architecture
// Namespace: Tsonic.Runtime
// Assembly: Tsonic.Runtime

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import support types from @tsonic/core
import type { ptr } from "@tsonic/core/types.js";

// Import types from other namespaces
import type { Dictionary, IEnumerable, IList } from "@tsonic/dotnet/System.Collections.Generic.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Action, Boolean as ClrBoolean, Func, IEquatable, Int32, Object as ClrObject, String as ClrString, Type, ValueType, Void } from "@tsonic/dotnet/System.js";

export interface IteratorResult_1$instance<T> {
    done: boolean;
    value: T;
    deconstruct(value: T, done: boolean): void;
    equals(obj: unknown): boolean;
    equals(other: IteratorResult_1<T>): boolean;
    getHashCode(): int;
    toString(): string;
}


export const IteratorResult_1: {
    new<T>(value: T, done: boolean): IteratorResult_1<T>;
};


export type IteratorResult_1<T> = IteratorResult_1$instance<T>;

export interface DictionaryAdapter_1$instance<T> {
    item: T | undefined;
    readonly keys: IEnumerable<System_Internal.String>;
    readonly values: IEnumerable<T | undefined>;
    containsKey(key: string): boolean;
    getDictionary(): Dictionary<System_Internal.String, unknown | undefined>;
}


export const DictionaryAdapter_1: {
    new<T>(dictionary: Dictionary<System_Internal.String, unknown>): DictionaryAdapter_1<T>;
};


export type DictionaryAdapter_1<T> = DictionaryAdapter_1$instance<T>;

export interface DynamicObject$instance {
    get item(): unknown | undefined;
    set item(value: unknown);
    getKeys(): string[];
    getProperty<T>(key: string): T | undefined;
    getValues(): (unknown | undefined)[];
    hasProperty(key: string): boolean;
    setProperty(key: string, value: unknown): void;
    toDictionary(): Dictionary<System_Internal.String, unknown | undefined>;
}


export const DynamicObject: {
    new(): DynamicObject;
    fromDictionary(properties: Dictionary<System_Internal.String, unknown>): DynamicObject;
};


export type DynamicObject = DynamicObject$instance;

export interface Union_2$instance<T1, T2> {
    as1(): T1;
    as2(): T2;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    is1(): boolean;
    is2(): boolean;
    match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>): TResult;
    match(onT1: Action<T1>, onT2: Action<T2>): void;
    toString(): string | undefined;
    tryAs1(value: T1): boolean;
    tryAs2(value: T2): boolean;
}


export const Union_2: {
    new<T1, T2>(): Union_2<T1, T2>;
    from1<T1, T2>(value: T1): Union_2<T1, T2>;
    from2<T1, T2>(value: T2): Union_2<T1, T2>;
};


export type Union_2<T1, T2> = Union_2$instance<T1, T2>;

export interface Union_3$instance<T1, T2, T3> {
    as1(): T1;
    as2(): T2;
    as3(): T3;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    is1(): boolean;
    is2(): boolean;
    is3(): boolean;
    match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>): TResult;
    match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>): void;
    toString(): string | undefined;
    tryAs1(value: T1): boolean;
    tryAs2(value: T2): boolean;
    tryAs3(value: T3): boolean;
}


export const Union_3: {
    new<T1, T2, T3>(): Union_3<T1, T2, T3>;
    from1<T1, T2, T3>(value: T1): Union_3<T1, T2, T3>;
    from2<T1, T2, T3>(value: T2): Union_3<T1, T2, T3>;
    from3<T1, T2, T3>(value: T3): Union_3<T1, T2, T3>;
};


export type Union_3<T1, T2, T3> = Union_3$instance<T1, T2, T3>;

export interface Union_4$instance<T1, T2, T3, T4> {
    as1(): T1;
    as2(): T2;
    as3(): T3;
    as4(): T4;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    is1(): boolean;
    is2(): boolean;
    is3(): boolean;
    is4(): boolean;
    match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>): TResult;
    match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>): void;
    toString(): string | undefined;
    tryAs1(value: T1): boolean;
    tryAs2(value: T2): boolean;
    tryAs3(value: T3): boolean;
    tryAs4(value: T4): boolean;
}


export const Union_4: {
    new<T1, T2, T3, T4>(): Union_4<T1, T2, T3, T4>;
    from1<T1, T2, T3, T4>(value: T1): Union_4<T1, T2, T3, T4>;
    from2<T1, T2, T3, T4>(value: T2): Union_4<T1, T2, T3, T4>;
    from3<T1, T2, T3, T4>(value: T3): Union_4<T1, T2, T3, T4>;
    from4<T1, T2, T3, T4>(value: T4): Union_4<T1, T2, T3, T4>;
};


export type Union_4<T1, T2, T3, T4> = Union_4$instance<T1, T2, T3, T4>;

export interface Union_5$instance<T1, T2, T3, T4, T5> {
    as1(): T1;
    as2(): T2;
    as3(): T3;
    as4(): T4;
    as5(): T5;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    is1(): boolean;
    is2(): boolean;
    is3(): boolean;
    is4(): boolean;
    is5(): boolean;
    match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>): TResult;
    match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>): void;
    toString(): string | undefined;
    tryAs1(value: T1): boolean;
    tryAs2(value: T2): boolean;
    tryAs3(value: T3): boolean;
    tryAs4(value: T4): boolean;
    tryAs5(value: T5): boolean;
}


export const Union_5: {
    new<T1, T2, T3, T4, T5>(): Union_5<T1, T2, T3, T4, T5>;
    from1<T1, T2, T3, T4, T5>(value: T1): Union_5<T1, T2, T3, T4, T5>;
    from2<T1, T2, T3, T4, T5>(value: T2): Union_5<T1, T2, T3, T4, T5>;
    from3<T1, T2, T3, T4, T5>(value: T3): Union_5<T1, T2, T3, T4, T5>;
    from4<T1, T2, T3, T4, T5>(value: T4): Union_5<T1, T2, T3, T4, T5>;
    from5<T1, T2, T3, T4, T5>(value: T5): Union_5<T1, T2, T3, T4, T5>;
};


export type Union_5<T1, T2, T3, T4, T5> = Union_5$instance<T1, T2, T3, T4, T5>;

export interface Union_6$instance<T1, T2, T3, T4, T5, T6> {
    as1(): T1;
    as2(): T2;
    as3(): T3;
    as4(): T4;
    as5(): T5;
    as6(): T6;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    is1(): boolean;
    is2(): boolean;
    is3(): boolean;
    is4(): boolean;
    is5(): boolean;
    is6(): boolean;
    match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>, onT6: Func<T6, TResult>): TResult;
    match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>, onT6: Action<T6>): void;
    toString(): string | undefined;
    tryAs1(value: T1): boolean;
    tryAs2(value: T2): boolean;
    tryAs3(value: T3): boolean;
    tryAs4(value: T4): boolean;
    tryAs5(value: T5): boolean;
    tryAs6(value: T6): boolean;
}


export const Union_6: {
    new<T1, T2, T3, T4, T5, T6>(): Union_6<T1, T2, T3, T4, T5, T6>;
    from1<T1, T2, T3, T4, T5, T6>(value: T1): Union_6<T1, T2, T3, T4, T5, T6>;
    from2<T1, T2, T3, T4, T5, T6>(value: T2): Union_6<T1, T2, T3, T4, T5, T6>;
    from3<T1, T2, T3, T4, T5, T6>(value: T3): Union_6<T1, T2, T3, T4, T5, T6>;
    from4<T1, T2, T3, T4, T5, T6>(value: T4): Union_6<T1, T2, T3, T4, T5, T6>;
    from5<T1, T2, T3, T4, T5, T6>(value: T5): Union_6<T1, T2, T3, T4, T5, T6>;
    from6<T1, T2, T3, T4, T5, T6>(value: T6): Union_6<T1, T2, T3, T4, T5, T6>;
};


export type Union_6<T1, T2, T3, T4, T5, T6> = Union_6$instance<T1, T2, T3, T4, T5, T6>;

export interface Union_7$instance<T1, T2, T3, T4, T5, T6, T7> {
    as1(): T1;
    as2(): T2;
    as3(): T3;
    as4(): T4;
    as5(): T5;
    as6(): T6;
    as7(): T7;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    is1(): boolean;
    is2(): boolean;
    is3(): boolean;
    is4(): boolean;
    is5(): boolean;
    is6(): boolean;
    is7(): boolean;
    match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>, onT6: Func<T6, TResult>, onT7: Func<T7, TResult>): TResult;
    match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>, onT6: Action<T6>, onT7: Action<T7>): void;
    toString(): string | undefined;
    tryAs1(value: T1): boolean;
    tryAs2(value: T2): boolean;
    tryAs3(value: T3): boolean;
    tryAs4(value: T4): boolean;
    tryAs5(value: T5): boolean;
    tryAs6(value: T6): boolean;
    tryAs7(value: T7): boolean;
}


export const Union_7: {
    new<T1, T2, T3, T4, T5, T6, T7>(): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    from1<T1, T2, T3, T4, T5, T6, T7>(value: T1): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    from2<T1, T2, T3, T4, T5, T6, T7>(value: T2): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    from3<T1, T2, T3, T4, T5, T6, T7>(value: T3): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    from4<T1, T2, T3, T4, T5, T6, T7>(value: T4): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    from5<T1, T2, T3, T4, T5, T6, T7>(value: T5): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    from6<T1, T2, T3, T4, T5, T6, T7>(value: T6): Union_7<T1, T2, T3, T4, T5, T6, T7>;
    from7<T1, T2, T3, T4, T5, T6, T7>(value: T7): Union_7<T1, T2, T3, T4, T5, T6, T7>;
};


export type Union_7<T1, T2, T3, T4, T5, T6, T7> = Union_7$instance<T1, T2, T3, T4, T5, T6, T7>;

export interface Union_8$instance<T1, T2, T3, T4, T5, T6, T7, T8> {
    as1(): T1;
    as2(): T2;
    as3(): T3;
    as4(): T4;
    as5(): T5;
    as6(): T6;
    as7(): T7;
    as8(): T8;
    equals(obj: unknown): boolean;
    getHashCode(): int;
    is1(): boolean;
    is2(): boolean;
    is3(): boolean;
    is4(): boolean;
    is5(): boolean;
    is6(): boolean;
    is7(): boolean;
    is8(): boolean;
    match<TResult>(onT1: Func<T1, TResult>, onT2: Func<T2, TResult>, onT3: Func<T3, TResult>, onT4: Func<T4, TResult>, onT5: Func<T5, TResult>, onT6: Func<T6, TResult>, onT7: Func<T7, TResult>, onT8: Func<T8, TResult>): TResult;
    match(onT1: Action<T1>, onT2: Action<T2>, onT3: Action<T3>, onT4: Action<T4>, onT5: Action<T5>, onT6: Action<T6>, onT7: Action<T7>, onT8: Action<T8>): void;
    toString(): string | undefined;
    tryAs1(value: T1): boolean;
    tryAs2(value: T2): boolean;
    tryAs3(value: T3): boolean;
    tryAs4(value: T4): boolean;
    tryAs5(value: T5): boolean;
    tryAs6(value: T6): boolean;
    tryAs7(value: T7): boolean;
    tryAs8(value: T8): boolean;
}


export const Union_8: {
    new<T1, T2, T3, T4, T5, T6, T7, T8>(): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from1<T1, T2, T3, T4, T5, T6, T7, T8>(value: T1): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from2<T1, T2, T3, T4, T5, T6, T7, T8>(value: T2): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from3<T1, T2, T3, T4, T5, T6, T7, T8>(value: T3): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from4<T1, T2, T3, T4, T5, T6, T7, T8>(value: T4): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from5<T1, T2, T3, T4, T5, T6, T7, T8>(value: T5): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from6<T1, T2, T3, T4, T5, T6, T7, T8>(value: T6): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from7<T1, T2, T3, T4, T5, T6, T7, T8>(value: T7): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
    from8<T1, T2, T3, T4, T5, T6, T7, T8>(value: T8): Union_8<T1, T2, T3, T4, T5, T6, T7, T8>;
};


export type Union_8<T1, T2, T3, T4, T5, T6, T7, T8> = Union_8$instance<T1, T2, T3, T4, T5, T6, T7, T8>;

export abstract class ArrayHelpers$instance {
    static slice<T>(source: IEnumerable<T>, startIndex: int): T[];
    static slice<T>(source: IList<T>, startIndex: int): T[];
    static slice<T>(source: T[], startIndex: int): T[];
}


export type ArrayHelpers = ArrayHelpers$instance;

export abstract class Operators$instance {
    static instanceof_(obj: unknown, type_: Type): boolean;
    static typeof_(value: unknown): string;
}


export type Operators = Operators$instance;

export abstract class Structural$instance {
    static clone<T>(source: unknown): T | undefined;
    static cloneFromDictionary<T>(source: Dictionary<System_Internal.String, unknown>): T | undefined;
    static createDictionaryAdapter<T>(source: Dictionary<System_Internal.String, unknown>): DictionaryAdapter_1<T>;
    static toDictionary(source: unknown): Dictionary<System_Internal.String, unknown | undefined>;
}


export type Structural = Structural$instance;

